// SPDX-FileCopyrightText: 2024 The Aalto Grades Developers
//
// SPDX-License-Identifier: MIT

import axios from 'axios';
import {load} from 'cheerio';
import fs from 'fs';
import {Plugin} from 'vite';

type Dependency = {
  name: string;
  license: string;
};

enum LicenseType {
  Free, // Declared free by the FSF
  NonFree, // Declared non-free by the FSF
  OpenSource, // No declaration from the FSF but declared open source by the OSI
  Unknown, // No declaration from the FSF and not declared open source by the OSI
}

type LicenseInfo = {
  id: string;
  url: string;
  type: LicenseType;
};

type Options = {
  /** Path of the index HTML file relative to the build directory. */
  indexFile: string;

  /**
   * Path of the JavaScript Web Labels HTML file relative to the build
   * directory.
   */
  webLabelsFile: string;

  /**
   * Path of a JSON dependencies file generated by the rollup license plugin
   * relative to the build directory.
   */
  dependenciesFile: string;

  /**
   * LibreJS or SPDX identifier of the project's license. This license is
   * expected to be listed manually in the Web Labels HTML file.
   */
  projectLicense: string;

  /**
   * SPDX identifiers of licenses which have been manually identified as free
   * but not listed as such in the SPDX license list.
   */
  licenseExceptions?: string[];

  /** Mapping from an arbitrary license string to an SPDX identifier. */
  licenseAliases?: {[key: string]: string | undefined};
};

/**
 * Attempts to transform a license string to an identifier recognized by
 * LibreJS.
 */
function transform(
  aliases: {[key: string]: string | undefined},
  license: string
): string {
  const spdxToLibreJsId: {[key: string]: string | undefined} = {
    'AGPL-3.0-only': 'AGPL-3.0',
    'AGPL-3.0-or-later': 'AGPL-3.0',
    'MIT': 'Expat', // prettier-ignore
    'BSD-2-Clause-FreeBSD': 'FreeBSD',
    'FSFAP': 'GNU-All-Permissive', // prettier-ignore
    'GPL-2.0-only': 'GPL-2.0',
    'GPL-2.0-or-later': 'GPL-2.0',
    'GPL-3.0-only': 'GPL-3.0',
    'GPL-3.0-or-later': 'GPL-3.0',
    'LGPL-2.1-only': 'LGPL-2.1',
    'LGPL-2.1-or-later': 'LGPL-2.1',
    'LGPL-3.0-only': 'LGPL-3.0',
    'LGPL-3.0-or-later': 'LGPL-3.0',
  };

  const alias = aliases[license] ?? license;
  return spdxToLibreJsId[alias] || alias;
}

async function makeLicenseList(
  exceptions: string[],
  aliases: {[key: string]: string | undefined}
): Promise<LicenseInfo[]> {
  // Licenses recognized as free by LibreJS
  const libreJsList = (
    await axios.get<{
      [key: string]: {
        identifier: string;
        canonicalUrl: string[];
      };
    }>(
      'https://git.savannah.gnu.org/cgit/librejs.git/plain/common/license_definitions.json'
    )
  ).data;

  const libreJsInfoList: LicenseInfo[] = Object.entries(libreJsList).map(
    val => ({
      id: val[1].identifier,
      url: val[1].canonicalUrl[0],
      type: LicenseType.Free,
    })
  );

  // Full SPDX license list, contains both free and non-free licenses
  const spdxList = (
    await axios.get<{
      licenses: {
        licenseId: string;
        reference: string;
        isFsfLibre?: boolean;
        isOsiApproved: boolean;
      }[];
    }>(
      'https://raw.githubusercontent.com/spdx/license-list-data/main/json/licenses.json'
    )
  ).data;

  const spdxInfoList: LicenseInfo[] = spdxList.licenses
    .map(val => {
      const type =
        val.isFsfLibre === undefined
          ? val.isOsiApproved
            ? LicenseType.OpenSource
            : LicenseType.Unknown
          : val.isFsfLibre
            ? LicenseType.Free
            : LicenseType.NonFree;

      const exception = Boolean(exceptions.includes(val.licenseId));
      if (exception && type === LicenseType.NonFree) {
        throw new Error(
          `${val.licenseId} is declared non-free and cannot be excepted`
        );
      }

      return {
        id: transform(aliases, val.licenseId),
        url: val.reference,
        type: exception ? LicenseType.Free : type,
      };
    })
    .filter(
      spdxInfo =>
        !libreJsInfoList.find(libreJsInfo => libreJsInfo.id === spdxInfo.id)
    );

  return [...libreJsInfoList, ...spdxInfoList];
}

function findLicenseInfo(
  list: LicenseInfo[],
  aliases: {[key: string]: string | undefined},
  dependency: Dependency
): LicenseInfo | undefined {
  return list.find(info => info.id === transform(aliases, dependency.license));
}

function validateLicense(
  dependency: Dependency,
  info: LicenseInfo | undefined
): info is LicenseInfo {
  if (!info) {
    throw new Error(
      `Dependency ${dependency.name} has an unrecognized license: ${dependency.license}. ` +
        'If this is a free software license, add it as an alias to the licenseExceptions property, otherwise this dependency MUST be removed.'
    );
  }

  switch (info.type) {
    case LicenseType.Free:
      return true;
    case LicenseType.NonFree:
      throw new Error(
        `Dependency ${dependency.name} has a NON-FREE license: ${info.id}. ` +
          'This dependency MUST be removed.'
      );
    case LicenseType.OpenSource:
      throw new Error(
        `Dependency ${dependency.name} has an open source license: ${info.id}. ` +
          'If this is a free software license, add it as exception to the licenseExceptions property, otherwise this dependency MUST be removed.'
      );
    case LicenseType.Unknown:
      throw new Error(
        `Dependency ${dependency.name} has an unknown license: ${info.id}. ` +
          'If this is a free software license, add it as exception to the licenseExceptions property, otherwise this dependency MUST be removed.'
      );
  }
}

export default function libreJs({
  indexFile,
  webLabelsFile,
  dependenciesFile,
  projectLicense,
  licenseExceptions = [],
  licenseAliases = {},
}: Options): Plugin {
  return {
    name: 'react-librejs',
    closeBundle() {
      const indexPath = `build/${indexFile}`;
      const webLabelsPath = `build/${webLabelsFile}`;
      const dependenciesPath = `build/${dependenciesFile}`;

      const index = load(fs.readFileSync(indexPath));
      const webLabels = load(fs.readFileSync(webLabelsPath));
      const dependencies = JSON.parse(
        fs.readFileSync(dependenciesPath).toString()
      ) as Dependency[];

      (async () => {
        const list = await makeLicenseList(licenseExceptions, licenseAliases);

        // Find the licenses of dependencies
        const webLabelsList: LicenseInfo[] = [];
        for (const dependency of dependencies) {
          const info = findLicenseInfo(list, licenseAliases, dependency);

          if (
            validateLicense(dependency, info) &&
            !webLabelsList.find(val => val.id === info.id) &&
            info.id !== transform(licenseAliases, projectLicense)
          ) {
            webLabelsList.push(info);
          }
        }

        // Add a link to the web labels file to the index file
        index(
          `<a href="/${webLabelsFile}" rel="jslicense" hidden=""></a>`
        ).appendTo('body');

        // Add dependency licenses to the web labels list
        for (const info of webLabelsList) {
          webLabels(`<a href="${info.url}">${info.id}</a>\n`).appendTo(
            '#licenses'
          );
        }

        // Add a link to the bundle script to the web labels list
        const script = index('script').get()[0].attribs.src;
        webLabels('#bundle').replaceWith(
          `<a id="bundle" href="${script}">${script}</a>`
        );

        fs.writeFileSync(indexPath, index.html());
        fs.writeFileSync(webLabelsPath, webLabels.html());
      })();
    },
  };
}
