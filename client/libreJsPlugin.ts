// SPDX-FileCopyrightText: 2024 The Aalto Grades Developers
//
// SPDX-License-Identifier: MIT

import axios from 'axios';
import {load} from 'cheerio';
import fs from 'fs';
import parse, {Info} from 'spdx-expression-parse';
import {Plugin} from 'vite';

type Dependency = {
  name: string;
  license: string;
};

enum LicenseType {
  Free, // Declared free by the FSF
  NonFree, // Declared non-free by the FSF
  OpenSource, // No declaration from the FSF but declared open source by the OSI
  Unknown, // No declaration from the FSF and not declared open source by the OSI
}

type LicenseInfo = {
  id: string;
  url: string;
  type: LicenseType;
};

type DependencyLicenseInfo =
  | {
      left: DependencyLicenseInfo;
      conjunction: 'and' | 'or';
      right: DependencyLicenseInfo;
    }
  | LicenseInfo
  | undefined;

type Options = {
  /** Path of the index HTML file relative to the build directory. */
  indexFile: string;

  /**
   * Path of the JavaScript Web Labels HTML file relative to the build
   * directory.
   */
  webLabelsFile: string;

  /**
   * Path of a JSON dependencies file generated by the rollup license plugin
   * relative to the build directory.
   */
  dependenciesFile: string;

  /**
   * LibreJS or SPDX identifier of the project's license. This license is
   * expected to be listed manually in the Web Labels HTML file.
   */
  projectLicense: string;

  /**
   * SPDX identifiers of licenses which have been manually identified as free
   * but not listed as such in the SPDX license list.
   */
  licenseExceptions?: string[];

  /** Mapping from an arbitrary license string to an SPDX identifier. */
  licenseAliases?: {[key: string]: string | undefined};
};

/**
 * Attempts to transform a license string to an identifier recognized by
 * LibreJS.
 */
function transform(
  aliases: {[key: string]: string | undefined},
  license: string
): string {
  const spdxToLibreJsId: {[key: string]: string | undefined} = {
    'AGPL-3.0-only': 'AGPL-3.0',
    'AGPL-3.0-or-later': 'AGPL-3.0',
    'MIT': 'Expat', // prettier-ignore
    'BSD-2-Clause-FreeBSD': 'FreeBSD',
    'FSFAP': 'GNU-All-Permissive', // prettier-ignore
    'GPL-2.0-only': 'GPL-2.0',
    'GPL-2.0-or-later': 'GPL-2.0',
    'GPL-3.0-only': 'GPL-3.0',
    'GPL-3.0-or-later': 'GPL-3.0',
    'LGPL-2.1-only': 'LGPL-2.1',
    'LGPL-2.1-or-later': 'LGPL-2.1',
    'LGPL-3.0-only': 'LGPL-3.0',
    'LGPL-3.0-or-later': 'LGPL-3.0',
  };

  const alias = aliases[license] ?? license;
  return spdxToLibreJsId[alias] || alias;
}

async function makeLicenseList(
  exceptions: string[]
): Promise<LicenseInfo[]> {
  // Licenses recognized as free by LibreJS
  const libreJsList = (
    await axios.get<{
      [key: string]: {
        identifier: string;
        canonicalUrl: string[];
      };
    }>(
      'https://git.savannah.gnu.org/cgit/librejs.git/plain/common/license_definitions.json'
    )
  ).data;

  const libreJsInfoList: LicenseInfo[] = Object.entries(libreJsList).map(
    val => ({
      id: val[1].identifier,
      url: val[1].canonicalUrl[0],
      type: LicenseType.Free,
    })
  );

  // Full SPDX license list, contains both free and non-free licenses
  const spdxList = (
    await axios.get<{
      licenses: {
        licenseId: string;
        reference: string;
        isFsfLibre?: boolean;
        isOsiApproved: boolean;
      }[];
    }>(
      'https://raw.githubusercontent.com/spdx/license-list-data/main/json/licenses.json'
    )
  ).data;

  const spdxInfoList: LicenseInfo[] = spdxList.licenses
    .map(val => {
      const type =
        val.isFsfLibre === undefined
          ? val.isOsiApproved
            ? LicenseType.OpenSource
            : LicenseType.Unknown
          : val.isFsfLibre
            ? LicenseType.Free
            : LicenseType.NonFree;

      const exception = Boolean(exceptions.includes(val.licenseId));
      if (exception && type === LicenseType.NonFree) {
        throw new Error(
          `${val.licenseId} is declared non-free and cannot be excepted`
        );
      }

      return {
        id: transform({}, val.licenseId),
        url: val.reference,
        type: exception ? LicenseType.Free : type,
      };
    })
    .filter(
      spdxInfo =>
        !libreJsInfoList.find(libreJsInfo => libreJsInfo.id === spdxInfo.id)
    );

  return [...libreJsInfoList, ...spdxInfoList];
}

function findLicenseInfo(
  list: LicenseInfo[],
  aliases: {[key: string]: string | undefined},
  dependency: Dependency
): DependencyLicenseInfo {
  const info = list.find(
    val => val.id === transform(aliases, dependency.license)
  );

  function traverseSpdxExpr(expr: Info): DependencyLicenseInfo {
    if ('license' in expr) {
      return list.find(val => val.id === transform(aliases, expr.license));
    }

    return {
      left: traverseSpdxExpr(expr.left),
      conjunction: expr.conjunction,
      right: traverseSpdxExpr(expr.right),
    };
  }

  if (!info) {
    return traverseSpdxExpr(parse(dependency.license));
  }

  return info;
}

function validateLicense(
  dependency: Dependency,
  info: DependencyLicenseInfo
): LicenseInfo[] {
  function traverseSpdxExpr(
    expr: DependencyLicenseInfo,
    throwError: boolean
  ): (LicenseInfo | Error)[] {
    function raiseError(message: string): [Error] {
      const error = new Error(message);
      if (throwError) {
        throw error;
      }

      return [error];
    }

    if (!expr) {
      return raiseError(
        `Dependency ${dependency.name} has an unrecognized license: ${dependency.license}. ` +
          'If this is a free software license, add it as an alias to the licenseExceptions property, otherwise this dependency MUST be removed.'
      );
    }

    if ('id' in expr) {
      switch (expr.type) {
        case LicenseType.Free:
          return [expr];
        case LicenseType.NonFree:
          return raiseError(
            `Dependency ${dependency.name} has a NON-FREE license: ${expr.id}. ` +
              'This dependency MUST be removed.'
          );
        case LicenseType.OpenSource:
          return raiseError(
            `Dependency ${dependency.name} has an open source license: ${expr.id}. ` +
              'If this is a free software license, add it as exception to the licenseExceptions property, otherwise this dependency MUST be removed.'
          );
        case LicenseType.Unknown:
          return raiseError(
            `Dependency ${dependency.name} has an unknown license: ${expr.id}. ` +
              'If this is a free software license, add it as exception to the licenseExceptions property, otherwise this dependency MUST be removed.'
          );
      }
    }

    switch (expr.conjunction) {
      case 'and': {
        const result = [
          ...traverseSpdxExpr(expr.left, false),
          ...traverseSpdxExpr(expr.right, false),
        ];

        const error = result.find(val => val instanceof Error);
        if (error) {
          throw error;
        }

        return result;
      }

      case 'or': {
        const left = traverseSpdxExpr(expr.left, false);
        const right = traverseSpdxExpr(expr.right, false);

        const leftError = left.find(val => val instanceof Error);
        const rightError = right.find(val => val instanceof Error);
        if (leftError && rightError) {
          throw leftError;
        }

        return [...(leftError ? [] : left), ...(rightError ? [] : right)];
      }
    }
  }

  return traverseSpdxExpr(info, true).filter(
    val => !(val instanceof Error)
  ) as LicenseInfo[];
}

export default function libreJs({
  indexFile,
  webLabelsFile,
  dependenciesFile,
  projectLicense,
  licenseExceptions = [],
  licenseAliases = {},
}: Options): Plugin {
  return {
    name: 'react-librejs',
    closeBundle() {
      const indexPath = `build/${indexFile}`;
      const webLabelsPath = `build/${webLabelsFile}`;
      const dependenciesPath = `build/${dependenciesFile}`;

      const index = load(fs.readFileSync(indexPath));
      const webLabels = load(fs.readFileSync(webLabelsPath));
      const dependencies = JSON.parse(
        fs.readFileSync(dependenciesPath).toString()
      ) as Dependency[];

      (async () => {
        const list = await makeLicenseList(licenseExceptions);

        // Find the licenses of dependencies
        const webLabelsList: LicenseInfo[] = [];
        for (const dependency of dependencies) {
          const infoList = validateLicense(
            dependency,
            findLicenseInfo(list, licenseAliases, dependency)
          );

          for (const info of infoList) {
            if (
              !webLabelsList.find(val => val.id === info.id) &&
              info.id !== transform(licenseAliases, projectLicense)
            ) {
              webLabelsList.push(info);
            }
          }
        }

        // Add a link to the web labels file to the index file
        index(
          `<a href="/${webLabelsFile}" rel="jslicense" hidden=""></a>`
        ).appendTo('body');

        // Add dependency licenses to the web labels list
        for (const info of webLabelsList) {
          webLabels(`<a href="${info.url}">${info.id}</a>\n`).appendTo(
            '#licenses'
          );
        }

        // Add a link to the bundle script to the web labels list
        const script = index('script').get()[0].attribs.src;
        webLabels('#bundle').replaceWith(
          `<a id="bundle" href="${script}">${script}</a>`
        );

        fs.writeFileSync(indexPath, index.html());
        fs.writeFileSync(webLabelsPath, webLabels.html());
      })();
    },
  };
}
