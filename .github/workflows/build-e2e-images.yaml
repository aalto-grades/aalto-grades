# SPDX-FileCopyrightText: 2024 The Ossi Developers
#
# SPDX-License-Identifier: MIT
---
name: Build E2E Images
on:
  workflow_call:
    outputs:
      docker-images-cache-key:
        description: Cache key for built Docker images
        value: ${{ jobs.build-images.outputs.docker-images-cache-key }}

jobs:
  build-images:
    name: Build Docker images for E2E tests
    runs-on: ubuntu-latest
    outputs:
      docker-images-cache-key: ${{ steps.generate-cache-key.outputs.key }}
    steps:
      - uses: actions/checkout@v4

      - name: Generate Docker images cache key
        id: generate-cache-key
        run: |
          # Create a cache key based on relevant files
          echo "key=docker-images-${{ runner.os }}-${{ hashFiles('**/Dockerfile*', '**/package*.json', 'docker-compose*.yaml') }}-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Check for cached Docker images
        id: docker-images-cache
        uses: actions/cache@v3
        with:
          path: /tmp/docker-images
          key: ${{ steps.generate-cache-key.outputs.key }}

      - name: Install NPM dependencies
        if: steps.docker-images-cache.outputs.cache-hit != 'true'
        run: npm ci

      - name: Clean up existing Docker containers
        if: steps.docker-images-cache.outputs.cache-hit != 'true'
        run: docker compose down --volumes --remove-orphans

      - name: Build Docker images
        if: steps.docker-images-cache.outputs.cache-hit != 'true'
        run: docker compose build --no-cache

      - name: Save Docker images to cache
        if: steps.docker-images-cache.outputs.cache-hit != 'true'
        run: |
          mkdir -p /tmp/docker-images

          echo "=== All available Docker images ==="
          docker images

          echo "=== Getting images built by docker-compose ==="
          # Use docker-compose to get the exact image names it created
          IMAGES=$(docker compose images --quiet | tr '\n' ' ')

          if [ -z "$IMAGES" ]; then
            echo "No images found via 'docker compose images', falling back to service-based approach..."
            # Alternative: get images by service names from docker-compose
            SERVICES=$(docker compose config --services)
            echo "Services found: $SERVICES"

            IMAGES=""
            for service in $SERVICES; do
              # Get the image name that docker-compose would use for each service
              IMAGE=$(docker compose images $service --quiet 2>/dev/null || true)
              if [ -n "$IMAGE" ]; then
                IMAGES="$IMAGES $IMAGE"
              fi
            done
          fi

          # Remove any duplicate spaces and trim
          IMAGES=$(echo $IMAGES | tr -s ' ' | sed 's/^ *//;s/ *$//')

          echo "=== Images to save ==="
          echo "Images: '$IMAGES'"

          if [ -n "$IMAGES" ]; then
            echo "Saving images to tar file..."
            docker save $IMAGES -o /tmp/docker-images/images.tar
            echo "✅ Images saved successfully to /tmp/docker-images/images.tar"

            # Verify what we saved
            echo "=== Tar file contents ==="
            tar -tf /tmp/docker-images/images.tar | head -10
            ls -lh /tmp/docker-images/images.tar
          else
            echo "❌ No images found to save, creating empty tar"
            tar -cf /tmp/docker-images/images.tar --files-from /dev/null
          fi
